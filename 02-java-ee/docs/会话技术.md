# 会话技术

浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止。在一次会话的范围内的多次请求间可以共享数据。

## Cookie

Cookie 可以一次性添加多次。

特殊字符和中文建议使用 URL 编码后再存储，使用时先利用 URL 解码。

在不设置有效期的情况下，浏览器关闭后，Cookie 就会被销毁。setMaxAge() 设置为0时表示立即删除 Cookie。

可以通过 setDomain(String path) 和 setPath(String path) 设置 Cookie 数据的共享范围。

浏览器对于单个 Cookie 的大小有限制（4kb）以及对同一个域名下的总 Cookie 数量也有限制。

Cookie 一般用于存储少量的不太敏感的数据。

在不登录的情况下，Cookie 可以完成服务器对客户端的身份识别。

小案例：

实现一个 Servlet，判断是否为第一次访问。第一次访问时，返回“您好，欢迎您首次访问”；不是第一次访问时，返回“欢迎回来，您上次访问时间为：xxxx年xx月xx日xx:xx:xx”。

@WebServlet(name = "VisitServlet", value = "/visitServlet")public class VisitServlet extends HttpServlet {    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        response.setContentType("text/html;charset=utf-8");        Cookie[] cookies = request.getCookies();        if (cookies != null) {            for (Cookie c : cookies) {                String name = c.getName();                if ("lastTime".equals(name)) {                    Date date = new Date();                    SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日 HH:mm:ss");                    String format = sdf.format(date);                    c.setValue(URLEncoder.encode(format, "UTF-8"));                    c.setMaxAge(300);                    String value = c.getValue();                    response.addCookie(c);                    response.getWriter().write("<h1>欢迎回来，您上次访问时间为:" + URLDecoder.decode(value, "UTF-8") + "</h1>");                    break;                }            }        } else {            Date date = new Date();            SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日 HH:mm:ss");            String format = sdf.format(date);            Cookie cookie = new Cookie("lastTime", URLEncoder.encode(format, "UTF-8"));            cookie.setMaxAge(300);            response.addCookie(cookie);            response.getWriter().write("<h1>您好，欢迎您首次访问</h1>");        }    }    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        this.doGet(request, response);    }}

## Session

服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。Session 的实现是依赖于 Cookie。

request.getSession()：获取 Session 对象。

getAttribute(String name)：

setAttribute(String name, Object value)：

removeAttribute(String name)：

Session 的销毁和浏览器是否关闭没有关系，以下几种情况下会导致 Session 失效：

服务器关闭。

Session 对象调用 invalidate()。

超时。Session 的存活时间和服务器设置有关，Tomcat 默认是30分钟。

通过配置，修改 web.xml。

<session-config>  <session-timeout>30</session-timeout></session-config>

特点：

Session 用于存储一次会话的多次请求的数据，存在服务器端。

Session 可以存储任意类型，任意大小的数据。

Session 相较于 Cookie 更加安全。

当客户端关闭后，服务器不关闭，两次访问的 session 默认不是同一个。如果需要相同，则可以创建 Cookie，键为JSESSIONID，设置最大存活时间，持久化保存。

客户端不关闭，服务器关闭后，两次获取的 session 默认也是不同的。思考：假如你在购物车中加入了几件商品，还没来及结算，服务器重启了，此时要结算时，就会发现购物车是空的。

Session 在一定时间内没有使用，Tomcat 就会以文件的方式把它保存到硬盘，这个过程叫做钝化。

钝化后，内存中的 Session 数据就会被清理，当再次使用到这个 Session 时，Tomcat 再从硬盘中把它读取到内存中，这个过程叫做活化。钝化和活化是服务器自动完成的，其实使用的就是序列化和反序列化技术，需要注意的是，Session 中保存的对象对应的类必须得实现 Serializable 接口，否则钝化时就会被移除，导致活化后数据丢失。

在本地 Tomcat 中部署一个项目，访问包含 session 的 Servlet，然后 shotdown.bat 正常关闭服务器，查看 /work 目录会发现 session 钝化后生成的文件。不要在 IDEA 中测试，因为每次重新启动服务器都会重新创建 /work 目录，所以永远不会有活化的 session。也可以实现 session 的监听器，查看重启后是不是重新初始化session

如果系统包含多台应用服务器，session 最好集中管理，而不是每台服务器都有一个完整的副本。把 session 统一存放在 redis 上，nginx 转发到不同的应用服务器上后都去 redis 读取 session。