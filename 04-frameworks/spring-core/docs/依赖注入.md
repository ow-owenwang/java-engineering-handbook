依赖注入，Dependency Injection。它是 Spring 框架核心 ioc 的具体实现。我们的程序在编写时，通过控制反转，把对象的创建交给了 Spring，但是代码中不可能出现没有依赖的情况。ioc 解耦只是降低他们的依赖关系，但不会消除。例如：我们的业务层仍会调用持久层的方法，持久层对象现在是由 Spring 管理的，如何把他们交给业务层对象呢，依赖注入就是解决这个问题的。



_<u>注意：如果是经常变化的数据，并不适用于注入的方式。</u>_





## 注入方式
依赖注入一共有三种方式，分别为构造函数注入、set 方法注入、p 名称空间注入。下面分别进行介绍：



### 构造函数注入
业务层实现类：

```java
/**
 * 账户的业务层实现类
 * <p>
 * 构造函数注入
 */
public class AccountServiceImpl implements IAccountService {

    private String name;
    private Integer age;
    private Date birthday;

    public AccountServiceImpl(String name, Integer age, Date birthday) {
        this.name = name;
        this.age = age;
        this.birthday = birthday;
    }

    @Override
    public void saveAccount() {
        System.out.println(name + "," + age + "," + birthday);
    }
}
```

配置：

```xml
<!--构造函数注入-->
<bean id="accountService" class="org.example.service.impl.AccountServiceImpl">
  <constructor-arg name="name" value="Doe"/>
  <constructor-arg name="age" value="20"/>
  <constructor-arg name="birthday" ref="now"/>
</bean>
<bean id="now" class="java.util.Date"/>
```

index:指定参数在构造函数参数列表的索引位置

type:指定参数在构造函数中的数据类型

name:指定参数在构造函数中的名称

value:它能赋的值是基本数据类型和 String 类型

ref:它能赋的值是其他 bean 类型，也就是说，必须得是在配置文件中配置过的 bean

### set 方法注入
此种方式需要在类中提供需要注入成员的 set 方法。实际开发中这种方法用的比较多。



业务层实现类：

```java
/**
 * set 方法注入
 */
public class AccountServiceImpl1 implements IAccountService {
    private String name;
    private Integer age;
    private Date birthday;

    public void setName(String name) {
        this.name = name;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public void setBirthday(Date birthday) {
        this.birthday = birthday;
    }

    @Override
    public void saveAccount() {
        System.out.println(name + "," + age + "," + birthday);
    }
}
```

配置：

```xml
<!--set 方法注入-->
<bean id="accountService1" class="org.example.service.impl.AccountServiceImpl1">
  <property name="name" value="Doe"/>
  <property name="age" value="20"/>
  <property name="birthday" ref="now"/>
</bean>
```

+ name：找的是类中 set 方法后面的部分
+ ref：给属性赋值是其他 bean 类型的
+ value：给属性赋值是基本数据类型和 String 类型的

### p 名称空间注入
此种方式是通过在配置文件中导入 p 名称空间，使用 `p:propertyName` 来注入数据，它的本质仍然是调用类中的 set 方法实现注入功能。



业务层实现类：

```java
/**
 * p 名称空间注入
 */
public class AccountServiceImpl2 implements IAccountService {
    private String name;
    private Integer age;
    private Date birthday;

    public void setName(String name) {
        this.name = name;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public void setBirthday(Date birthday) {
        this.birthday = birthday;
    }

    @Override
    public void saveAccount() {
        System.out.println(name + "," + age + "," + birthday);
    }
}
```

配置：

配置文件中需要引入 `xmlns:p="[http://www.springframework.org/schema/p"](http://www.springframework.org/schema/p")`，然后再添加 `<bean>` 标签的具体配置。

```xml
<!--p 名称空间注入-->
<bean id="accountService2" class="org.example.service.impl.AccountServiceImpl2" p:name="Doe" p:age="20"
      p:birthday-ref="now"/>
```



## 支持注入的数据类型
Spring 不仅支持注入普通类型和 String 类型，以及 bean 类型，还支持注入复杂类型，如集合、数组等。



前面讲解注入方式时，已经对普通类型、String 类型以及 bean 类型的数据注入做了演示，此处不再赘述。下面介绍复杂类型的数据注入。



业务层实现类：

```java
/**
 * 账户的业务层实现类
 */
public class AccountServiceImpl3 implements IAccountService {

    private String[] myStrs;
    private List<String> myList;
    private Set<String> mySet;
    private Map<String,String> myMap;
    private Properties myProps;

    public void setMyStrs(String[] myStrs) {
        this.myStrs = myStrs;
    }

    public void setMyList(List<String> myList) {
        this.myList = myList;
    }

    public void setMySet(Set<String> mySet) {
        this.mySet = mySet;
    }

    public void setMyMap(Map<String, String> myMap) {
        this.myMap = myMap;
    }

    public void setMyProps(Properties myProps) {
        this.myProps = myProps;
    }

    public void  saveAccount(){
        System.out.println(Arrays.toString(myStrs));
        System.out.println(myList);
        System.out.println(mySet);
        System.out.println(myMap);
        System.out.println(myProps);
    }
}
```

配置：

```xml
<!--复杂类型注入-->
<bean id="accountService3" class="org.example.service.impl.AccountServiceImpl3">
  <property name="myStrs">
    <array>
      <value>AA</value>
      <value>BB</value>
    </array>
  </property>
  <property name="myList">
    <list>
      <value>AA</value>
      <value>BB</value>
    </list>
  </property>
  <property name="mySet">
    <set>
      <value>AA</value>
      <value>BB</value>
    </set>
  </property>
  <property name="myMap">
    <map>
      <entry key="AA" value="AA_VALUE"/>
      <entry key="BB" value="BB_VALUE"/>
    </map>
  </property>
  <property name="myProps">
    <props>
      <prop key="AA">AA_VALUE</prop>
      <prop key="BB">BB_VALUE</prop>
    </props>
  </property>
</bean>
```



注意：

+ 在注入集合数据时，只要结构相同，标签可以互换。
+ 复杂数据类型的注入原理其实就是给类中的成员传值，它用的也是 set 方法注入的方式。















