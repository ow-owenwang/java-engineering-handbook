# 泛型

集合中是可以存放任意类型的对象的，这一特性方便了开发，但同时也带来了隐患。因为对象存储到集合中时，会自动提升为 Object 类型，而当我们在使用某个元素之前都需要进行强制类型转换，如果强制类型转换时遇到无法转换的元素就会抛出异常。

//没有泛型的集合可以存储任意类型的数据Collection collection = new ArrayList();collection.add("A");collection.add("B");collection.add(123);Iterator it = collection.iterator();while (it.hasNext()) {    //强转时出现异常    String str = (String) it.next();    System.out.println(str);}

为了解决这一问题，JDK5 中新增了泛型语法，它避免了繁琐的类型强转，并且将运行时期的 ClassCastException 异常，转移到了编译时期，让开发者在编码阶段就能发现隐患。

Collection<String> list = new ArrayList<>();list.add("A");list.add("B");//编译错误//list.add(123);Iterator<String> it = list.iterator();while (it.hasNext()) {    //此处不需要强转    String str = it.next();    System.out.println(str);}

当我们不能确定数据类型时可以使用泛型。

## 泛型类

假如我们需要一个数据的包装类，通过传入不同类型的数据，可以存储相应类型的数据。我们看看这个简单的泛型类的设计：

public class DataHolder<T> {    private T data;    public void setData(T data) {        this.data = data;    }    public T getData() {        return this.data;    }}

使用泛型类：

Integer[] nums = {1, 2, 3};//创建对象的时候确定泛型的数据类型DataHolder<Integer[]> holder = new DataHolder<>();holder.setData(nums);String s = Arrays.toString(holder.getData());System.out.println(s);

泛型类定义时只需要在类名后面加上类型参数即可，当然你也可以添加多个参数，类似于<K,V>,<T,E,K>等。这样我们就可以在类里面使用定义的类型参数。

泛型类可以参考集合类源码，如 ArrayList。

## 泛型方法

泛型方法既可以存在于泛型类中，也可以存在于普通的类中。如果使用泛型方法可以解决问题，那么应该尽量使用泛型方法。

自定义泛型方法：

public class MyUtil {    public static <E> void print(E e) {        System.out.println("增强打印：" + e);    }    public <T> T get(T t) {        return t;    }}

使用泛型方法：

MyUtil.print("abc");MyUtil myUtil = new MyUtil();Integer i = myUtil.get(3);System.out.println(i);

## 泛型接口

自定义泛型接口：

public interface CustomGenericInterface<E> {    public abstract void add(E e);    public abstract E get();}

实现接口时确定泛型的类型：

继承泛型类或者实现泛型接口时，可以指明泛型的类型。

public class CustomGenericInterfaceImpl implements CustomGenericInterface<String> {    private String str;    @Override    public void add(String s) {        str = s;    }    @Override    public String get() {        return str;    }}

还有一种情况，始终不确定泛型的类型，直到创建对象时，确定泛型的类型。

public class CustomGenericInterfaceImpl1<E> implements CustomGenericInterface<E> {    private E e;    @Override    public void add(E e1) {        e = e1;    }    @Override    public E get() {        return e;    }}

使用以上两个实现类：

CustomGenericInterfaceImpl cgi = new CustomGenericInterfaceImpl();CustomGenericInterfaceImpl1<String> cgi1 = new CustomGenericInterfaceImpl1<>();

## 泛型通配符

当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符 <?> 表示。但是一旦使用泛型的通配符后，只能使用 Object 类中的共性方法，集合中元素自身方法无法使用。

基本用法：

public class GenericWildcard {    public void method(Collection<?> collection) {        System.out.println(collection);    }}

ArrayList<Integer> list1 = new ArrayList<>();list1.add(1);ArrayList<String> list2 = new ArrayList<>();list2.add("A");GenericWildcard gw = new GenericWildcard();gw.method(list1);//[1]gw.method(list2);//[A]

设置泛型时，虽然泛型指代的数据类型是任意的，但是可以对泛型指定一个范围。

高级用法：

public class GenericWildcard {    public void method(Collection<?> collection) {        System.out.println(collection);    }    /**     * 必须是 Number 类型或者 Number 类型的子类     *     * @param collection     */    public void method01(Collection<? extends Number> collection) {        System.out.println(collection);    }    /**     * 必须是 Number 类型或者 Number 类型的父类     *     * @param collection     */    public void method02(Collection<? super Number> collection) {        System.out.println(collection);    }}

Collection<Integer> list1 = new ArrayList<Integer>();Collection<String> list2 = new ArrayList<String>();Collection<Number> list3 = new ArrayList<Number>();Collection<Object> list4 = new ArrayList<Object>();GenericWildcard gw = new GenericWildcard();gw.method01(list1);//gw.method01(list2);//报错gw.method01(list3);//gw.method01(list4);//报错//gw.method02(list1);//报错//gw.method02(list2);//报错gw.method02(list3);gw.method02(list4);

不允许向声明为通配符的集合类中写入对象，唯一例外 null。

List<? extends Number> list = new ArrayList<>();//list.add("123");//报错list.add(null);System.out.println(list);