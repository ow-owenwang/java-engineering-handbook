# 集合

集合可以看作是一个容器。我们可以很容易将各个对象存放到集合中，也可以很容易将其从集合中取出来，还可以将其按照一定的顺序进行摆放。Java中提供了不同的集合类，这些类具有不同的存储对象的方式，并提供了相应的方法以方便用户对集合进行遍历、添加、删除以及查找指定对象。

一方面， 面向对象语言对事物的体现都是以对象的形式，为了方便对多个对象的操作，就要对对象进行存储。另一方面，使用Array存储对象方面具有一些弊端，而Java 集合就像一种容器，可以动态地把多个对象的引用放入容器中。

Java 集合类可以用于存储数量不等的多个对象，还可用于保存具有映射关系的关联数组。

提到容器不难想到数组，集合类与数组的不同之处是，数组的长度是固定的，集合的长度是可变的；数组用来存放基本类型的数据，集合用来存放对象的引用。常用集合类的继承关系如图：

![](assets/document_image_rId4.png)

# Collection 接口

Collection 接口是 List、Set 和 Queue 接口的父接口，该接口里定义的方法既可用于操作 Set 集合，也可用于操作 List 和 Queue 集合。

JDK不提供此接口的任何直接实现，而是提供更具体的子接口(如：Set和List)实现。

在 Java5 之前，Java 集合会丢失容器中所有对象的数据类型，把所有对象都当成 Object 类型处理；从 Java5 增加了泛型以后，Java 集合可以记住容器中对象的数据类型

Collection 接口是层次结构中的根接口。Collection 通常不能直接使用，但是该接口提供了添加元素、删除元素、管理数据的方法。由于 List 接口与 Set 接口都继承了 Collection 接口，因此这些方法对 List 集合与 Set 集合是通用的。

常用方法：

方法

功能描述

add(E e)

将指定的对象添加到该集合中

remove(Object o)

将指定的对象从该集合中移除

isEmpty()

返回 boolean 值，用于判断当前集合是否为空

iterator()

返回在此 Collection 的元素上进行迭代的迭代器。用于遍历集合中的对象

size()

返回 int 型值，获取该集合中元素的个数

通常遍历集合，都是通过迭代器来实现。下面的实例就是典型的遍历集合的方法。

import java.util.*;public class Muster {    public static void main(String[] args) {        Collection<String> list = new ArrayList<>();        list.add("a");        list.add("b");        list.add("c");        Iterator<String> it = list.iterator();        while (it.hasNext()) {            String str = (String) it.next();            System.out.println(str);        }    }}

注意：Iterator 的 next() 方法返回的是 Object

# Iterator 接口

Iterator对象称为迭代器(设计模式的一种)，主要用于遍历 Collection 集合中的元素。

所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象。

Iterator 仅用于遍历集合，Iterator 本身并不提供承装对象的能力。如果需要创建 Iterator 对象，则必须有一个被迭代的集合。

方法：

方法

功能描述

hasNext()

next()

remove()

![](assets/document_image_rId4.png)

在调用it.next()方法之前必须要调用it.hasNext()进行检测。若不调用，且下一条记录无效，直接调用it.next()会抛出NoSuchElementException异常。

Java 5 提供了 foreach 循环迭代访问 Collection。

# List 集合

Java 中数组用来存储数据的局限性

List 集合类中元素有序、且可重复，集合中的每个元素都有其对应的顺序索引。与数组相同，集合的索引也是从0开始。

List 容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素。

JDK API 中 List 接口的实现类常用的有：ArrayList、LinkedList和Vector。

List 集合里添加了一些根据索引来操作集合元素的方法：

方法

功能描述

get(int index)

获取指定索引位置的元素

set(int index, Object obj)

将集合中指定索引位置的对象修改为指定的对象

## ArrayList 实现类

数组的长度是固定的，无法适应数据变化的需求。为了解决这个问题，Java提供了另一个容器 java.util.ArrayList 集合类,让我们可以更便捷的存储和操作对 象数据。

java.util.ArrayList 是大小可变的数组的实现，存储在内的数据称为元素。此类提供一些方法来操作内部存储的元素。 ArrayList 中可不断添加元素，其大小也自动增长。

ArrayList对象不能存储基本类型，只能存储引用类型的数据。类似 `<int>` 不能写，但是存储基本数据类型对应的包装类型是可以的。所以，想要存储基本类型数据， `<>` 中的数据类型，必须是对应包装类的名称。

数组的长度是固定的，无法适应数据变化的需求。为了解决这个问题，Java 提供了另一个容器java.util.ArrayList 集合类，让我们可以更便捷的存储和操作对象数据。它允许保存所有值，包括 null。

ArrayList 是线程不安全的，而 Vector 是线程安全的，但是即使 List 集合线程不安全，也不推荐使用 Vector。

java.util.ArrayList 是大小可变的数组的实现，存储在内的数据称为元素。此类提供一些方法来操作内部存储的元素。 ArrayList 中可不断添加元素，其大小也自动增长。

java.util.ArrayList <E>  ： <E>  表示一种指定的数据类型，叫做泛型。 E  取自 Element（元素）的首字母。在出现 E 的地方，我们使用一种引用数据类型将其替换即可，表示我们将存储哪种引用类型的元素。代码如下：

ArrayList<String>ArrayList<Student>

Arrays.asList(…) 方法返回的 List 集合既不是 ArrayList 实例，也不是 Vector 实例。 Arrays.asList(…)  返回值是一个固定长度的 List 集合

可以根据索引位置对集合进行快速的随机访问；缺点是向指定的索引位置插入对象或者删除对象的速度较慢。

实例化：

ArrayList<String> list = new ArrayList<String>();//在 JDK 7 后,右侧泛型的尖括号之内可以留空，但是 <> 仍然要写。简化格式：ArrayList<String> list = new ArrayList<>();

ArrayList 对象不能存储基本类型，只能存储引用类型的数据。类似 <int> 不能写，但是存储基本数据类型对应的包装类型是可以的。所以，想要存储基本类型数据， <> 中的数据类型，必须使用基本类型对应的包装类，转换写法如下：

基本类型

基本类型包装类

byte

Byte

short

Short

int

Integer

long

Long

float

Float

double

Double

char

Character

boolean

Boolean

案例：

import java.util.ArrayList;import java.util.List;public class Test {    public static void main(String[] args) {        List<String> list = new ArrayList<>();        list.add("a");        list.add("b");        list.add("c");        // 0~2之间的随机数        int i = (int) (Math.random() * list.size());        System.out.println(list.get(i));    }}/*从JDK 1.5+开始，支持自动装箱、自动拆箱。自动装箱：基本类型 --> 包装类型自动拆箱：包装类型 --> 基本类型 */ArrayList<Integer> listC = new ArrayList<>();listC.add(100);listC.add(200);

对于ArrayList集合来说，直接打印得到的不是地址值，而是内容。

如果内容是空，得到的是空的中括号：[]

## LinkedList 实现类

LinkedList 类采用链表结构保存对象。这种结构的优点是便于向集合中插入和删除对象，而且效率较高；但对于随机访问集合中的对象，使用 LinkedList 类效率较低。

实例化：

List<E> list = new LinkedList<>();

void addFirst(Object obj)

void addLast(Object obj)

Object getFirst()

Object getLast()

Object removeFirst()

Object removeLast()

## Vector

Vector 是一个古老的集合，JDK1.0就有了。大多数操作与ArrayList相同，区别之处在于Vector是线程安全的。

在各种list中，最好把ArrayList作为缺省选择。当插入、删除频繁时，使用LinkedList；Vector总是比ArrayList慢，所以尽量避免使用。

新增方法：

void addElement(Object obj)

void insertElementAt(Object obj,int index)

void setElementAt(Object obj,int index)

void removeElement(Object obj)

void removeAllElements()

## ListIterator

List 额外提供了一个 listIterator() 方法，该方法返回一个 ListIterator 对象， ListIterator 接口继承了 Iterator 接口，提供了专门操作 List 的方法：

void add()

boolean hasPrevious()

Object previous()

Boolean hasNext()

Object next()

Iterator 和 ListIterator 主要区别

一、ListIterator和Iterator都有hasNext()和next()方法，可以实现顺序向后遍历。但是ListIterator有hasPrevious()和previous()方法，可以实现逆向（顺序向前）遍历。Iterator就不可以。

二、ListIterator可以定位当前的索引位置，nextIndex()和previousIndex()可以实现。Iterator 没有此功能。

三、ListIterator有add()方法，可以向List中插入对象，而Iterator不能。

四、都可实现删除对象，但是ListIterator可以实现对象的修改，set()方法可以实现。Iterator仅能遍历，不能修改。因为ListIterator的这些功能，可以实现对LinkedList等List数据结构的操作。

# Set 集合

Set接口是Collection的子接口，set接口没有提供额外的方法。

Set 集合不允许包含相同的元素，如果试把两个相同的元素加入同一个 Set 集合中，则添加操作失败。

Set 判断两个对象是否相同不是使用 == 运算符，而是根据 equals 方法

## HashSet

HashSet 是 Set 接口的典型实现，大多数时候使用 Set 集合时都使用这个实现类。

HashSet 按 Hash 算法来存储集合中的元素，因此具有很好的存取和查找性能。

HashSet 具有以下特点：

不能保证元素的排列顺序

HashSet 不是线程安全的

集合元素可以是 null

当向 HashSet 集合中存入一个元素时，HashSet 会调用该对象的 hashCode() 方法来得到该对象的 hashCode 值，然后根据 hashCode 值决定该对象在 HashSet 中的存储位置。

HashSet 集合判断两个元素相等的标准：两个对象通过 hashCode() 方法比较相等，并且两个对象的 equals() 方法返回值也相等。

hashCode() 方法

如果两个元素的 equals() 方法返回 true，但它们的 hashCode() 返回值不相等，hashSet 将会把它们存储在不同的位置，但依然可以添加成功。

对于存放在Set容器中的对象，对应的类一定要重写equals()和hashCode(Object obj)方法，以实现对象相等规则。

重写 hashCode() 方法的基本原则

在程序运行时，同一个对象多次调用 hashCode() 方法应该返回相同的值

当两个对象的 equals() 方法比较返回 true 时，这两个对象的 hashCode() 方法的返回值也应相等

对象中用作 equals() 方法比较的 Field，都应该用来计算 hashCode 值

## LinkedHashSet

LinkedHashSet 是 HashSet 的子类

LinkedHashSet 根据元素的 hashCode 值来决定元素的存储位置，但它同时使用链表维护元素的次序，这使得元素看起来是以插入顺序保存的。

LinkedHashSet插入性能略低于 HashSet，但在迭代访问 Set 里的全部元素时有很好的性能。

LinkedHashSet 不允许集合元素重复。

## TreeSet

TreeSet 类不仅实现了 Set 接口，还实现了 java.util.SortedSet 接口，因此，TreeSet 类实现的 Set 集合在遍历时顺序递增排序，也可以按照指定比较器递增排序，即可以通过比较器对用 TreeSet 类实现的 Set 集合中的对象进行排序。TreeSet 类新增的方法如下：

方法

功能描述

first()

返回此 Set 中第一个（最低）元素

last()

返回此 Set 中最后一个（最高）元素

comparator()

返回对此 Set 中的元素进行排序的比较器。如果此 Set 使用自然顺序，则返回 null

headSet(E toElement)

返回一个新的 Set 集合，新集合是 toElement （不包含）之前的所有对象

subSet(E fromElement, E fromElement)

返回一个新的 Set 集合，是 fromElement（包含）对象与 fromElement（不包含）对象之间的所有对象

tailSet(E fromElement)

返回一个新的 Set 集合，新集合包含对象 fromElement（包含）之后的所有对象

TreeSet 是 SortedSet 接口的实现类，TreeSet 可以确保集合元素处于排序状态。

Comparator comparator()

Object first()

Object last()

Object lower(Object e)

Object higher(Object e)

SortedSet subSet(fromElement, toElement)

SortedSet headSet(toElement)

SortedSet tailSet(fromElement)

TreeSet 两种排序方法：自然排序和定制排序。默认情况下，TreeSet 采用自然排序。

自然排序

自然排序：TreeSet 会调用集合元素的 compareTo(Object obj) 方法来比较元素之间的大小关系，然后将集合元素按升序排列

如果试图把一个对象添加到 TreeSet 时，则该对象的类必须实现 Comparable 接口。

实现 Comparable 的类必须实现 compareTo(Object obj) 方法，两个对象即通过 compareTo(Object obj) 方法的返回值来比较大小。

Comparable 的典型实现：

BigDecimal、BigInteger 以及所有的数值型对应的包装类：按它们对应的数值大小进行比较

Character：按字符的 unicode值来进行比较

Boolean：true 对应的包装类实例大于 false 对应的包装类实例

String：按字符串中字符的 unicode 值进行比较

Date、Time：后边的时间、日期比前面的时间、日期大

向 TreeSet 中添加元素时，只有第一个元素无须比较compareTo()方法，后面添加的所有元素都会调用compareTo()方法进行比较。

因为只有相同类的两个实例才会比较大小，所以向 TreeSet 中添加的应该是同一个类的对象

对于 TreeSet 集合而言，它判断两个对象是否相等的唯一标准是：两个对象通过 compareTo(Object obj) 方法比较返回值

当需要把一个对象放入 TreeSet 中，重写该对象对应的 equals() 方法时，应保证该方法与 compareTo(Object obj) 方法有一致的结果：如果两个对象通过 equals() 方法比较返回 true，则通过 compareTo(Object obj) 方法比较应返回 0

定制排序

TreeSet的自然排序是根据集合元素的大小，进行元素升序排列。如果需要定制排序，比如降序排列，可通过Comparator接口的帮助。需要重写compare(T o1,T o2)方法。

利用int compare(T o1,T o2)方法，比较o1和o2的大小：如果方法返回正整数，则表示o1大于o2；如果返回0，表示相等；返回负整数，表示o1小于o2。

要实现定制排序，需要将实现Comparator接口的实例作为形参传递给TreeSet的构造器。

此时，仍然只能向TreeSet中添加类型相同的对象。否则发生ClassCastException异常。

使用定制排序判断两个元素相等的标准是：通过Comparator比较两个元素返回了0。

# Map 集合

![](assets/document_image_rId4.png)

Map与Collection并列存在。用于保存具有映射关系的数据:Key-Value

Map 中的 key 和  value 都可以是任何引用类型的数据

Map 中的 key 用Set来存放，不允许重复，即同一个 Map 对象所对应的类，须重写hashCode()和equals()方法。

常用String类作为Map的“键”。

key 和 value 之间存在单向一对一关系，即通过指定的 key 总能找到唯一的、确定的 value。

添加、删除操作：

Object put(Object key,Object value)

Object remove(Object key)

void putAll(Map t)

void clear()

元视图操作的方法：

Set keySet()

Collection values()

Set entrySet()

元素查询的操作：

Object get(Object key)

boolean containsKey(Object key)

boolean containsValue(Object value)

int size()

boolean isEmpty()

boolean equals(Object obj)

## HashMap

Map接口的常用实现类：HashMap、TreeMap和Properties。

HashMap是 Map 接口使用频率最高的实现类。

允许使用null键和null值，与HashSet一样，不保证映射的顺序。

HashMap 判断两个 key 相等的标准是：两个 key 通过 equals() 方法返回 true，hashCode 值也相等。

HashMap 判断两个 value相等的标准是：两个 value 通过 equals() 方法返回 true。

## LinkedHashMap

LinkedHashMap 是 HashMap 的子类

与LinkedHashSet类似，LinkedHashMap 可以维护 Map 的迭代顺序：迭代顺序与 Key-Value 对的插入顺序一致

## TreeMap

TreeMap存储 Key-Value 对时，需要根据 key-value 对进行排序。TreeMap 可以保证所有的 Key-Value 对处于有序状态。

TreeMap 的 Key 的排序：

自然排序：TreeMap 的所有的 Key 必须实现 Comparable 接口，而且所有的 Key 应该是同一个类的对象，否则将会抛出 ClasssCastException

定制排序：创建 TreeMap 时，传入一个 Comparator 对象，该对象负责对 TreeMap 中的所有 key 进行排序。此时不需要 Map 的 Key 实现 Comparable 接口

TreeMap判断两个key相等的标准：两个key通过compareTo()方法或者compare()方法返回0。

若使用自定义类作为TreeMap的key，所属类需要重写equals()和hashCode()方法，且equals()方法返回true时，compareTo()方法应返回0。

## Hashtable

Hashtable是个古老的 Map 实现类，线程安全。

与HashMap不同，Hashtable 不允许使用 null 作为 key 和 value

与HashMap一样，Hashtable 也不能保证其中 Key-Value 对的顺序

Hashtable判断两个key相等、两个value相等的标准，与hashMap一致。

## Properties

Properties 类是 Hashtable 的子类，该对象用于处理属性文件

由于属性文件里的 key、value 都是字符串类型，所以 Properties 里的 key 和 value 都是字符串类型

存取数据时，建议使用setProperty(String key,String value)方法和getProperty(String key)方法

# 操作集合的工具类：Collections

Collections 是一个操作 Set、List 和 Map 等集合的工具类

Collections 中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法

排序操作：（均为static方法）

reverse(List)：反转 List 中元素的顺序

shuffle(List)：对 List 集合元素进行随机排序

sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序

sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序

swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换

查找、替换Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素

Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素

Object min(Collection)

Object min(Collection，Comparator)

int frequency(Collection，Object)：返回指定集合中指定元素的出现次数

void copy(List dest,List src)：将src中的内容复制到dest中

boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换 List 对象的所有旧值

操作数组的工具类：Arrays

同步控制

Collections 类中提供了多个 synchronizedXxx() 方法，该方法可使将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题

# Enumeration

Enumeration 接口是 Iterator 迭代器的 “古老版本”

Enumeration stringEnum = new StringTokenizer("a-b*c-d-e-g", "-");	while(stringEnum.hasMoreElements()){		Object obj = stringEnum.nextElement();		System.out.println(obj); 	}