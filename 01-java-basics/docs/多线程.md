# 多线程

程序是指指令和数据的有序集合，其本身没有任何运行的含义，是一个静态的概念。而进程则是执行程序的一次执行过程，它是一个动态的概念。是系统资源分配的单位。通常一个进程中可以包含若干个线程，当然一个进程中至少有一个线程，不然没有存在的意义。

线程(Thread)是进程的一个实体，是CPU调度和分派的基本单位。 线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 线程和进程的关系是：线程是属于进程的，线程运行在进程空间内，同一进程所产生的线程共享同一内存空间，当进程退出时该进程所产生的线程都会被强制退出并清除。

线程就是独立的执行路径。

在程序运行时，即使没有自己创建线程，后台也会有多个线程存在，如主线程、GC线程。

main()方法是程序的入口，用于执行整个程序，它所在的线程成为主线程。

在一个进程中，入股哦开辟了多个线程，线程的运行由调度器安排调度，调度器是与操作系统紧密相关的，先后顺序是不能人为干预的。

对同一份资源进行操作时，会存在资源争抢的问题，需要加入并发控制。

多线程会带来额外的开销，如CPU调度时间，并发控制开销。

每个线程在自己的工作内存交互，内存控制不当会造成数据不一致。

线程创建好后，不一定立即执行，需要cpu安排调度。

使用继承Tread的方式会存在单继承的局限性，推荐使用Runnable来实现多线程，而且支持同一个对象被多个线程同时使用。

## 状态

![](assets/document_image_rId4.png)

join()：join的线程执行完毕后再执行其他线程，可以想象成插队。

## 线程状态

NEW：尚未启动的线程处于此状态。

RUNNABLE：在Java虚拟机中执行的线程处于此状态。

BLOCKED：被阻塞等待监视器锁定的额线程处于此状态。

WAITING：正在等待另一个线程执行特定动作的线程处于此状态。

TIMED_WAITING：正在等待另一个线程执行动作达到指定等待时间的线程处于此状态。

TERMINATED：已推出的线程处于此状态。

## 线程同步

由于同一进程的多个线程共享同一块存储空间，在带来方便的同时，也带来了访问冲突，为了保证数据在方法中被访问时的正确性，在访问时加入了锁机制，当一个线程获得对象的排他锁，会独占资源，其他线程必须等待。锁的机制可以解决线程安全，但也会带来一些问题：

一个线程持有锁会导致其他所有需要此锁的线程挂起。

在多个线程竞争下，加锁和释放锁会导致比较多的上下文切换，调度延时，导致性能问题。

如果一个优先级高的线程等待一个优先级低的线程释放锁，会导致优先级倒置，引起性能问题。

synchronized和Lock的比较：

Lock是显示锁，需要手动开启和关闭，synchronized是隐式锁，出了作用域自动释放。

Lock只有代码块锁，synchronized有代码块锁和方法锁。

使用Lock锁，JVM将花费较少的时间来调度线程，性能更好，并且具有更好的扩展性（提供了更多的子类）。

## 线程通信

Java提供了几个方法解决线程之间的通信问题。

wait()：调用此方法后，线程一直等待，直到其他线程通知，与sleep()不同，它会释放锁。

wait(long timeout)：指定等待的毫秒数。

notify()：唤醒一个处于等待状态的线程。

notifyAll()：唤醒同一个对象上所有调用wait()方法的线程，优先级别高的线程优先调度。以上方法都是Object类的方法，都只能在同步方法或者同步代码块中使用，否则会抛出异常。

## 死锁

产生死锁的4个必要条件：

互斥条件，一个资源每次只能被一个进程使用。

请求与保持条件，一个进程因请求资源而阻塞时，对已获得的资源保持不放。

不剥夺条件，进程已获得的资源，在未使用完之前，不能强行剥夺。

循环等待条件，若干进程之间形成一种头尾相接的循环等待资源关系。

上面列出了死锁的4个必要条件，我们只要想办法破其中的任意一个或多个条件就可以避免死锁发生。

## 守护线程

线程分为用户线程和守护线程。

虚拟机必须确保用户线程执行完毕。

虚拟机不用等待守护线程执行完毕。

应用场景：后台记录操作日志、监控内存、垃圾回收等。

并发：同一个对象被多个线程同时操作。如抢票、取款。

多个线程访问同一个对象，并且可能某些线程可能会修改这个对象，这是就会有线程安全问题。通过线程同步可以解决线程安全问题，线程同步其实就是一种等待机制，多个需要同时访问此对象的线程进入这个对象的等待池形成队列，等待前面的线程使用完毕，然后下一个线程再使用。