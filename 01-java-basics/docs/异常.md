# 异常

在使用计算机语言进行项目开发的过程中，即使程序员把代码写得尽善尽美，在系统的运行过程中仍然会遇到一些问题，因为很多问题不是靠代码能够避免的，比如：客户输入数据的格式，读取文件是否存在，网络是否始终保持通畅等等。

## 概念

在Java语言中，将程序执行中发生的非正常情况称为“异常”。而异常的出现会导致 JVM 的非正常停止。

开发过程中的语法错误和逻辑错误不属于异常，如果语法错了，编译根本不会通过，不会产生字节码文件，根本不能运行。

在 Java 等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java 处理异常的方式是中断处理。

## 异常体系

异常机制其实是帮助我们找到程序中的问题，异常的根类是 java.lang.Throwable ，其下有两个子类： java.lang.Error 与 java.lang.Exception ，平常所说的异常指 java.lang.Exception 。

![](assets/document_image_rId4.png)

Error:  Java 虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。无法通过处理的错误，只能事先避免。

Exception: 其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如：

空指针访问

试图读取不存在的文件

网络连接中断

Throwable中的常用方法：

public void printStackTrace()：打印异常的详细信息。包含了异常的类型，异常的原因，还包括异常出现的位置，在开发和调试阶段，都得使用printStackTrace。

public String getMessage()：获取发生异常的原因。提示给用户的时候，就提示错误原因。

public String toString()：获取异常的类型和异常描述信息。

## 异常分类

编译时期异常：checked 异常，必须处置的异常。在编译时期，就会检查，如果没有处理异常，则编译失败。

运行时期异常：runtime 异常，编译器不要求强制处置的异常。在运行时期，检查异常，在编译时期，运行异常不会编译器检测(不报错)。对于这类异常，可以不作处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影响。

![](assets/document_image_rId4.png)

## 异常产生过程

![](assets/document_image_rId4.png)

## 异常处理

在编写程序时，经常要在可能出现错误的地方加上检测的代码，如进行x/y运算时，要检测分母为0，数据为空，输入的不是数据而是字符等。过多的分支会导致程序的代码加长，可读性差。因此采用异常机制。

Java提供的是异常处理的抓抛模型。

Java程序的执行过程中如出现异常，会生成一个异常类对象，该对象将被提交给Java运行时系统，这个过程称为抛出(throw)异常。

异常对象的生成

由虚拟机自动生成：程序运行过程中，虚拟机检测到程序发生了问题，如果在当前代码中没有找到相应的处理程序，就会在后台自动创建一个对应异常类的实例对象并抛出——自动抛出

由开发人员手动创建：Exception exception = new ClassCastException();

在 Java 中，如果某个方法抛出了异常，既可以在当前方法中进行捕获，然后处理该异常，也可以将异常向上抛出，由方法调用者来处理。如果都不处理，一直向上抛，那么最终会到 main 方法，如果 main 方法也不处理，则程序会运行终止。

### 抛出异常 throw

在编写程序时，我们必须要考虑程序出现问题的情况。比如，在定义方法时，方法需要接受参数。那么，当调用方法使用接收到的参数时，首先需要先对参数数据进行合法的判断，数据若不合法，就应该告诉调用者，传递合法的数据进来。这时需要使用抛出异常的方式来告诉调用者。

//throw new 异常类名(参数);throw new NullPointerException("要访问的arr数组不存在");throw new ArrayIndexOutOfBoundsException("该索引在数组中不存在，已超出范围");

注意：

throw 关键字必须写在方法的内部

throw 关键字后边 new 的对象必须是 Exception 或者 Exception 的子类对象

throw 关键字抛出指定的异常对象，我们就必须处理这个异常对象

throw 关键字后边创建的是 RuntimeException 或者是 RuntimeException 的子类对象，我们可以不处理，默认交给 JVM 处理(打印异常对象，中断程序)

throw 关键字后边创建的是编译异常，我们就必须处理这个异常，要么 throws，要么 try...catch

Objects 非空判断：

Objects 类中有一些静态方法是 null-save（空指针安全的）或 null-tolerant（容忍空指针的），那么在它的源码中，对对象为 null 的值进行了抛出异常操作。

public static <T> T requireNonNull(T obj)：查看指定引用对象不是 null。

查看源码发现这里对为 null 的进行了抛出异常操作：

public static <T> T requireNonNull(T obj) {    if (obj == null)      	throw new NullPointerException();    return obj;}

### 声明异常 throws

声明抛出异常是 Java 中处理异常的第二种方式，如果一个方法（中的语句执行时）可能生成某种异常，但是并不能确定如何处理这种异常，则此方法应显示地声明抛出异常，表明该方法将不对这些异常进行处理，而由该方法的调用者负责处理。

声明异常：将问题标识出来，报告给调用者。 如果方法内通过 throw 抛出了编译时异常，而没有捕获处理，那么必须通过 throws 进行声明，让调用者去处理。

关键字 throws 运用于方法声明之上，用于表示当前方法不处理异常，而是提醒该方法的调用者来处理异常（抛出异常）。

修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…{   }

注意：

throws 关键字必须写在方法声明处

throws 关键字后边声明的异常必须是 Exception 或者是 Exception 的子类

方法内部如果抛出了多个异常对象，那么 throws 后边必须也声明多个异常

如果抛出的多个异常对象有子父类关系，那么直接声明父类异常即可

调用了一个声明抛出异常的方法，我们就必须的处理声明的异常。要么继续使用 throws 声明抛出，交给方法的调用者处理，最终交给JVM。要么 try...catch 自己处理异常。

![](assets/document_image_rId4.png)

### 捕获异常 try-catch

如果异常出现的话，会立刻终止程序，所以我们得处理异常。

格式：

try{	......	//可能产生异常的代码}catch( ExceptionName1 e ){	......	//当产生ExceptionName1型异常时的处理代码}catch( ExceptionName2 e ){...... 	//当产生ExceptionName2型异常时的处理代码    //记录日志/打印异常信息/继续抛出异常}  [ finally{......	 //无论是否发生异常，都无条件执行的语句}]

try

捕获异常的第一步是用try{…}语句块选定捕获异常的范围，将可能出现异常的代码放在try语句块中。

catch (Exceptiontype e)

在catch语句块中是对异常对象进行处理的代码。每个try语句块可以伴随一个或多个catch语句，用于处理可能产生的不同类型的异常对象。

如果明确知道产生的是何种异常，可以用该异常类作为catch的参数；也可以用其父类作为catch的参数。

finally

有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而 finally 就是解决这个问题的，在 finally 代码块中存放的代码都是一定会被执行的。

不论在try代码块中是否发生了异常事件，catch语句是否执行，catch语句是否有异常，catch语句中是否有return，finally块中的语句都会被执行。

如果 finally 有 return 语句，永远返回 finally 中的结果，避免该情况。

实际开发中也经常使用 fanally 来关闭使用完的物理资源（磁盘文件/网络连接/数据库连接等）。

![](assets/document_image_rId4.png)

### 异常信息

![](assets/document_image_rId4.png)

### 多个异常如何处理

多个异常分别处理。

多个异常一次捕获，多次处理。

多个异常一次捕获一次处理。

一般我们是使用一次捕获多次处理方式，格式如下：

try{    编写可能会出现异常的代码}catch(异常类型A  e){  当try中出现A类型异常，就用该catch来捕获。    处理异常的代码    //记录日志/打印异常信息/继续抛出异常}catch(异常类型B  e){  当try中出现B类型异常，就用该catch来捕获。    处理异常的代码    //记录日志/打印异常信息/继续抛出异常}

注意：这种异常处理方式，要求多个 catch 中的异常不能相同，并且若 catch 中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的 catch 处理，父类异常在下面的 catch 处理。

### 注意

如果父类抛出了多个异常，子类重写父类方法时，抛出和父类相同的异常或者是父类异常的子类或者不抛出异常。

父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出。

## 自定义异常

Java 中不同的异常类，分别表示着某一种具体的异常情况，那么在开发中总是有些异常情况是 官方没有定义好的，此时我们根据自己业务的异常情况来定义异常类。例如年龄负数问题，考试成绩负数问题等等。

注意：

自定义异常类一般都是以 Exception 结尾，说明该类是一个异常类

自定义异常类，必须继承 Exception 或者 RuntimeException

继承 Exception：那么自定义的异常类就是一个编译期异常，如果方法内部抛出了编译期异常，就必须处理这个异常，要么 throws，要么 try...catch

继承 RuntimeException：那么自定义的异常类就是一个运行期异常，无需处理，交给虚拟机处理（中断处理）

创建用户自定义异常类

一般地，用户自定义异常类都是RuntimeException的子类。

自定义异常类通常需要编写几个重载的构造器。

自定义的异常类对象通过throw抛出。

自定义异常最重要的是异常类的名字，当异常出现时，可以根据名字判断异常类型。

用户自定义异常类MyException，用于描述数据取值范围错误信息。用户自己的异常类必须继承现有的异常类。

class MyException extends Exception {   	static final long serialVersionUID = 1L;	private int idnumber; 	public MyException(String message, int id) {		super(message);		this.idnumber = id; 	} 	public int getId() {		return idnumber; 	}}

使用用户自定义异常类

public class Test6_5{        public void regist(int num) throws MyException { 	if (num < 0)  	          throw new MyException(“人数为负值，不合理”, 3);	else	          System.out.println("登记人数" + num );        }        public void manager() { 	try {	           regist(100); 	} catch (MyException e) { 	           System.out.print("登记失败，出错种类"+e.getId());	 		}	System.out.print("本次登记操作结束");       }       public static void main(String args[]){	Test6_5 t = new Test6_5();	t.manager();       }}