# 内存结构

程序计数器

虚拟机栈

本地方法栈

堆

方法区

## 程序计数器

程序计数器（寄存器），Program Counter Register。它的作用是记住下一条jvm指令的执行地址。

下面是一段jvm指令（二进制字节码）：

0: getstatic #20 // PrintStream out = System.out;3: astore_1 // --4: aload_1 // out.println(1);5: iconst_1 // --6: invokevirtual #26 // --9: aload_1 // out.println(2);10: iconst_2 // --11: invokevirtual #26 // --14: aload_1 // out.println(3);15: iconst_3 // --16: invokevirtual #26 // --19: aload_1 // out.println(4);20: iconst_4 // --21: invokevirtual #26 // --24: aload_1 // out.println(5);25: iconst_5 // --26: invokevirtual #26 // --29: return

计算机不能直接执行jvm指令，jvm指令必须得经过解释器处理转化为机器码，然后cpu再执行机器码。

特点：

是线程私有的

不会存在内存溢出

## 虚拟机栈

虚拟机栈（Java Virtual Machine Stacks），每个线程运行时所需要的内存，称为虚拟机栈。每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存。每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法。

![](assets/document_image_rId4.png)

问题辨析：

垃圾回收是否涉及栈内存？

栈内存不要垃圾回收进行管理，执行完自动释放。

栈内存分配的越大越好吗？

可以通过以下参数设置栈内存大小。栈内存大小可以决定调用方法的多少，但不会提高系统性能。因为栈内存越大，可以开启的线程数就会越小，因为物理内存大小是固定的。

![](assets/document_image_rId4.png)

https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE

方法内的局部变量是否是线程安全的？

如果方法内局部变量没有逃离方法的作用范围，它是线程安全的；如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全。

栈内存溢出：

栈帧过多导致栈内存溢出。

栈帧过大导致栈内存溢出。

线程运行诊断

使用top命令定位哪个进程对CPU的占用过高。

ps H -eo pid,tid,%cpu | grep 进程id，进一步定位哪个线程引起的CPU过高。

jstack 进程id

下图为jstack打印的信息，可以根据之前查询到的线程id（tid需要从之前的十进制，转换为下面的十六进制，才能从下图中查找到）找到有问题的线程，进一步定位到问题代码的源码行号。

![](assets/document_image_rId4.png)

程序运行很长时间没有结果

可能是出现了死锁，也是使用jstack分析。

## 本地方法栈

给本地方法提供运行的空间。

## 堆

通过new关键字，创建对象都会使用堆内存。

特点：

它是线程共享的，堆中对象都需要考虑线程安全的问题

有垃圾回收机制

堆内存溢出

堆内存诊断

jps工具：查看当前系统中有哪些java进程

jmap工具：查看堆内存占用情况jmap - heap 进程id

jconsole工具：图形界面的，多功能的监测工具，可以连续监测

垃圾回收后，内存占用仍然很高？

使用jvisualvm工具进行分析。

## 方法区

![](assets/document_image_rId4.png)

https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4

组成：

![](assets/document_image_rId4.png)

方法区内存溢出：

1.8以前会导致永久代内存溢出，平时在使用spring和mybatis时，使用不当非常容易产生永久代内存溢出，因为它们都会创建大量的代理对象。

1.8之后会导致元空间内存溢出

运行时常量池：

常量池，就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息。

运行时常量池，常量池是*.class文件中的，当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址。

StringTable：

String s1 = "a";String s2 = "b";String s3 = "a" + "b";String s4 = s1 + s2;String s5 = "ab";String s6 = s4.intern();// 问System.out.println(s3 == s4);System.out.println(s3 == s5);System.out.println(s3 == s6);String x2 = new String("c") + new String("d");String x1 = "cd";x2.intern();// 问，如果调换了【最后两行代码】的位置呢，如果是jdk1.6呢System.out.println(x1 == x2);

特性：

常量池中的字符串仅是符号，第一次用到时才变为对象

利用串池的机制，来避免重复创建字符串对象

字符串变量拼接的原理是 StringBuilder （1.8）

字符串常量拼接的原理是编译期优化

可以使用 intern 方法，主动将串池中还没有的字符串对象放入串池

1.8 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池， 会把串

池中的对象返回

1.6 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有会把此对象复制一份，

放入串池， 会把串池中的对象返回