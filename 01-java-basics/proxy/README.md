# Proxy 代理模式知识点总结

## 1. 简介

代理模式是一种设计模式，提供了对目标对象额外的访问方式，即通过代理对象访问目标对象，这样可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。

简言之，代理模式就是设置一个中间代理来控制访问原目标对象，以达到增强原对象的功能和简化访问方式。

## 2. 核心概念

### 2.1 静态代理

这种代理方式需要代理对象和目标对象实现一样的接口。

**优点：**
- 可以在不修改目标对象的前提下扩展目标对象的功能。

**缺点：**
- **冗余**：由于代理对象要实现与目标对象一致的接口，会产生过多的代理类。
- **不易维护**：一旦接口增加方法，目标对象与代理对象都要进行修改。

### 2.2 动态代理

动态代理利用了 JDK API，动态地在内存中构建代理对象，从而实现对目标对象的代理功能。动态代理又被称为 JDK 代理或接口代理。

**静态代理与动态代理的区别：**
- **静态代理**：在编译时就已经实现，编译完成后代理类是一个实际的 class 文件。
- **动态代理**：是在运行时动态生成的，即编译完成后没有实际的 class 文件，而是在运行时动态生成类字节码，并加载到 JVM 中。

**特点：**
- 动态代理对象不需要实现接口，但是要求目标对象必须实现接口，否则不能使用动态代理。
- 使用 `java.lang.reflect.Proxy` 和 `java.lang.reflect.InvocationHandler` 实现。

### 2.3 CGLib 代理

CGLib (Code Generation Library) 是一个第三方代码生成类库，运行时在内存中动态生成一个子类对象从而实现对目标对象功能的扩展。

**特点：**
- JDK 的动态代理有一个限制，就是使用动态代理的对象必须实现一个或多个接口。如果想代理没有实现接口的类，就可以使用 CGLIB 实现。
- CGLIB 是一个强大的高性能的代码生成包，它可以在运行期扩展 Java 类与实现 Java 接口。它广泛的被许多 AOP 的框架使用，例如 Spring AOP 和 dynaop，为他们提供方法的 interception（拦截）。
- CGLIB 包的底层是通过使用一个小而快的字节码处理框架 ASM，来转换字节码并生成新的类。不鼓励直接使用 ASM，因为它需要你对 JVM 内部结构包括 class 文件的格式和指令集都很熟悉。

**CGLib 与动态代理最大的区别：**
- 使用动态代理的对象必须实现一个或多个接口。
- 使用 CGLib 代理的对象则无需实现接口，达到代理类无侵入。

**依赖：**
- 使用 CGLib 需要引入 CGLib 的 jar 包，如果你已经有 spring-core 的 jar 包，则无需引入，因为 Spring 中包含了 CGLib。

## 3. 三种代理方式对比

| 代理方式 | 实现方式 | 优点 | 缺点 | 适用场景 |
|---------|---------|------|------|---------|
| 静态代理 | 手动编写代理类 | 简单直观 | 冗余、不易维护 | 简单的代理需求 |
| 动态代理 | JDK 反射机制 | 灵活、减少代码 | 目标对象必须实现接口 | 有接口的类 |
| CGLib 代理 | 字节码生成 | 无需接口、性能较好 | 需要第三方库 | 无接口的类 |

## 4. 示例代码

请参考本目录下的 `code/proxy-demo/src/main/java/org/example/` 路径下的代码示例：

### 4.1 静态代理
`staticProxy/` 目录：
- `UserDaoProxy.java`: 静态代理类实现
- `Demo.java`: 静态代理使用示例

### 4.2 动态代理
`dynamicProxy/` 目录：
- `ProxyFactory.java`: 动态代理工厂类，使用 `java.lang.reflect.Proxy`
- `Demo.java`: 动态代理使用示例（基于 UserDao 接口）

**根目录下的动态代理示例：**
- `Demo01.java`: 展示动态代理的基本用法，包含多个接口（A、B）的代理
- `Demo02.java`: 展示动态代理的实际应用（Waiter 服务示例）
- `Waiter.java`: 服务员接口
- `ManWaiter.java`: 服务员实现类

### 4.3 CGLib 代理
`cg/` 目录：
- `ProxyFactory1.java`: CGLib 代理工厂类
- `Demo.java`: CGLib 代理使用示例
- `UserDao1.java`: 被代理类（无需实现接口）

### 4.4 增强型动态代理
`demo02/` 目录（更完善的动态代理实现）：
- `ProxyFactory.java`: 支持前置和后置增强的代理工厂类
- `BeforeAdvice.java`: 前置增强接口
- `AfterAdvice.java`: 后置增强接口
- `Demo.java`: 使用增强型代理工厂的示例

**说明：**
- `demo02/ProxyFactory` 相比 `dynamicProxy/ProxyFactory` 提供了更灵活的增强机制
- 支持前置增强（BeforeAdvice）和后置增强（AfterAdvice）
- 可以更灵活地控制代理行为

